虽然std::vector是C++中非常方便和通用的数据结构，但在使用它时，还是需要注意一些事项：

访问元素时要检查下标：当你使用operator[]访问元素时，std::vector不会检查下标是否有效。如果你访问了一个不存在的元素，会导致未定义的行为。你可以使用at()函数来访问元素，这个函数会检查下标，如果无效，它会抛出std::out_of_range异常。

注意迭代器失效：当你对std::vector进行插入或删除操作时，如果改变了vector的容量，那么所有的迭代器都可能失效。这意味着你不能再使用这些迭代器来访问元素。此外，如果你删除了一个元素，指向后续元素的迭代器也会失效。

预分配内存：如果你知道要存储多少元素，使用reserve()函数预先分配内存可以提高性能，因为它可以避免多次重新分配和复制操作。

尽量使用emplace_back()代替push_back()：emplace_back()函数可以在vector的末尾直接构造元素，而不需要先构造临时对象然后再复制。这样可以提高性能，特别是当元素的复制代价很高时。

使用std::vector::swap()释放多余的内存：当你删除了vector中的很多元素，vector的容量并不会减小，这意味着它可能占用了很多不需要的内存。你可以创建一个临时的副本，然后使用swap()函数来交换它们，这样就可以释放多余的内存了。
--------
std::vector::swap() 是一个简单的方法，用于交换两个向量的内容。它的原理基于C++中的移动语义，交换两个向量的内容实际上只是交换了他们的内部指针，而不需要逐个元素进行交换，所以效率非常高。
以下是一个 std::vector::swap() 的示例：

#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {6, 7, 8, 9, 10};

    vec1.swap(vec2);

    std::cout << "vec1 contains:";
    for (unsigned int i = 0; i < vec1.size(); i++)
        std::cout << ' ' << vec1[i];
    std::cout << '\n';

    std::cout << "vec2 contains:";
    for (unsigned int i = 0; i < vec2.size(); i++)
        std::cout << ' ' << vec2[i];
    std::cout << '\n';

    return 0;
}
输出结果：

vec1 contains: 6 7 8 9 10
vec2 contains: 1 2 3 4 5
如你所见，vec1 和 vec2 的内容已经交换了。
------------

使用const迭代器：如果你不需要修改元素，使用const迭代器可以防止意外的修改。

使用范围for循环来遍历元素：这是一种简洁且安全的方法，可以防止下标错误。

使用empty()检查是否为空，而不是检查size()是否为0：这样更直观，且可能更高效。


---------hyc 1 -------
当你在 std::vector 中存放指针时，有几个需要注意的点：
内存管理：当你在 vector 中存放指针时，你需要确保这些指针指向的内存在 vector 生命周期内都是有效的。如果这些指针指向的内存在某个时候被释放了，那么 vector 中的这些指针就会变成悬空指针，再次访问它们可能会导致未定义的行为。
内存泄露：你需要确保所有在 vector 中的指针在 vector 被销毁前都被正确地释放。如果你忘记释放这些指针，那么它们指向的内存就会泄露。
深拷贝和浅拷贝：当你复制一个存放指针的 vector 时，默认的复制行为是浅拷贝，也就是说新的 vector 中的指针与原 vector 中的指针指向同一块内存。如果你希望进行深拷贝，也就是复制指针指向的内容，那么你需要自己实现。
为了避免上述问题，一种更好的方式是使用智能指针（例如 std::unique_ptr 或 std::shared_ptr）而不是原始指针。这样，内存管理就会变得更加安全和容易。

