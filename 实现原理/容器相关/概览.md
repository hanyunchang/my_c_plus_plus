序列容器：这些容器维护元素的线性顺序。
vector：动态数组，支持在尾部快速插入、删除和随机访问。实现原理是通过动态申请和释放内存空间，当vector的内存空间不足时，它会重新申请更大的内存空间，并将原来的元素复制到新的内存空间。

list：双向链表，支持两端快速插入、删除。实现原理是通过链表节点的前后指针来实现元素的添加和删除。

deque：双端队列，支持两端快速插入、删除和随机访问。实现原理是通过动态申请和释放内存空间，并维护头部和尾部的指针来实现。

array：固定大小数组，支持快速随机访问。实现原理是在栈上分配固定大小的内存空间。

forward_list：单向链表，支持快速插入、删除。实现原理是通过链表节点的后指针来实现元素的添加和删除。


注：关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。
有序的关联容器：这些容器自动排序或按键组织元素。set的实现可能直接基于红黑树实现，并不存储值，也可能基于map实现
set/multiset：基于红黑树的集合容器，元素唯一/元素可重复。实现原理是通过红黑树这种自平衡二叉查找树来维护元素的有序性和查找性能。
map/multimap：基于红黑树的键值对容器，键唯一/键可重复。实现原理同set/multiset。

无序的无序容器：这些容器通过哈希函数组织元素。
unordered_set/unordered_multiset：基于哈希表的集合容器，元素唯一/元素可重复。实现原理是通过哈希函数将元素映射到哈希表的不同位置，通过开放地址法或链地址法解决哈希冲突。
unordered_map/unordered_multimap：基于哈希表的键值对容器，键唯一/键可重复。实现原理同unordered_set/unordered_multiset。



容器适配器(也是序列容器)：这些容器对其他容器进行封装，提供不同的接口。
stack：堆栈容器，后进先出。实现原理是对底层容器（如vector、deque或list）进行封装，只提供顶部元素的访问、插入和删除操作。
queue：队列容器，先进先出。实现原理是对底层容器（如deque或list）进行封装，提供两端元素的访问和一端的插入和另一端的删除操作。
priority_queue：优先队列，元素按优先级出队。实现原理是对底层容器（如vector或deque）进行封装，并使用make_heap、push_heap和pop_heap算法维护堆性质。

